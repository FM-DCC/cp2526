\documentclass[aspectratio=169]{beamer}

\input{src/macros/preamble}
\input{src/macros/sli_aux}

\begin{document}

% \setLectureBasic{Cyber-Physical Computation}
\setLecture[\\\emph{(slides mainly from Nelma Moreira)}]%
    {1}{Concurrent programming}

\section{Concurrent Programming - Part I}

\begin{frame}
\frametitle{Objectivos}
\begin{itemize}
  \item descrição formal dos conceitos básicos de concorrência e sua aplicação
\item raciocinar sobre a  correção de programas concorrentes  em relação a especificações
\item desenho e análise de programas concorrentes
\end{itemize} 
\end{frame}

\begin{frame}
\frametitle{Parte 1}
\begin{itemize}
\item Conceitos básicos de programação concorrente
\item Noções básicas de concorrência
\item Sistemas de transições
\item CCS: \emph{Calculus of Communicating Systems}:
sequência, composição, sincronização;
restrição e reetiquetagem;
parâmetros e dados
\item Comportamento observável
\begin{itemize}
\item relações de equivalência, congruência, bisimulações; 
\item congruência observável
\item propriedades algébricas
\end{itemize}
\item Problemas de sincronização: exclusão mútua, deadlock, locks, etc.
%\item pseuCo: linguagem de programação para agentes concorrentes
%\begin{itemize}
%\item pseuCo e CCS
%\item cooperação por passagem de mensagens (canais síncronos e assíncronos)
%\item cooperação por partilha de memória
%\item primitivas de sincronização (exclusão mútua, semáforos, locks, barreiras e monitors)
%\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Bibliografia e Software}
  \begin{itemize}
    \item Reactive systems modelling, specification and verification. Luca Aceto, Anna Ingólfsdóttir, Kim Guldstrand Larsen, Jiri Srba
2007 (Cap. 1-4 e 7)
\item Introduction to Concurrency Theory.
Roberto Gorrieri and Cristian Versari
2015
\item Communication and Concurrency, Robin Milner.
 Prentice Hall International Series in Computer Science, 1989.
\item Modelação usando simuladores de CCS, p.e.: 
  \begin{itemize}
    \item \href{https://lmf.di.uminho.pt/ccs-caos/}{CCS-CAOS}
    \item \href{https://mcrl2.org}{mCRL2.org}
    \item \href{https://pseuco.com}{pseuco.Com}
    \item \href{http://caal.cs.aau.dk}{CAAL}
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}{Concurrent Programming - Part II}

  \vspace*{-2mm}

  \begin{block}{Blocks of sequential code running concurrently and sharing memory:}
    
  \begin{itemize}
    \item What is \structure{\textbf{Scala}} and why using it?
    \item Concurrency in Java and its memory model
    \item Basic concurrency blocks and libraries
    \item Futures and promises
    \item Actor model
  \end{itemize}
  \end{block}

  % We will study is a \emph{\textbf{good/better}} algorithm
  % \begin{itemize}
  % \item correct (do what is expected and always terminates)
  % \item fast/faster (does not take forever...)
  % \end{itemize}

  \vspace*{2mm}

  \frsplitt[0.44]{
  We will be \alert{\textbf{less formal}}
  \begin{itemize}
    \item focus on concepts and programs
    \item study operators and libraries
    \item tool support with \structure{\textbf{Scala}}
  \end{itemize}
  }{
  We will have \alert{\textbf{hands-on}}
  \begin{itemize}
    \item Practical programming exercises
    \item Apply the concepts we learn
  \end{itemize}
  }
\end{frame}


\begin{frame}[t]\centering
  
  \includegraphics[width=5cm]{src/img/nam/cc.png}
  ~~~~~
  \includegraphics[page=1, scale=0.35]%
  {../../learning-concurrent-scala/learning-concurrent-programming-in-scala.pdf}
   % \fromBook[scale=0.3]{-19}{0mm}{0mm}{0mm}{0mm}

\end{frame}


\section{Logistics}

\begin{frame}{Useful information}
  Relevant class material and announcements will be posted on the website periodically

  % {\centering\mybox{\url{https://fm-dcc.github.io/pc2324}}

  % }
  \mycbox{\url{https://fm-dcc.github.io/cp2526}}


  \frsplitdiff{0.45}{0.45}{
    \alert{Lecturer}
    \begin{itemize}
      \item \textbf{José Proença}\\\url{https://jose.proenca.org}
      \item \href{mailto:jose.proenca@fc.up.pt}{jose.proenca@fc.up.pt}
      \item tba %Thursday afternoon
    \end{itemize}
    }{
    \structure{More links}
    \begin{itemize}
      \item Sigarra: \url{https://sigarra.up.pt/fcup/en/UCURR_GERAL.FICHA_UC_VIEW?pv_ocorrencia_id=570334}
      % \item \textcolor{black!20}{Moodle: \texttt{https://moodle2526.up.pt/user/ index.php?id=5713}}
    \end{itemize}
  }
           
   \bigskip

  % \alert{Office hours}
  \emph{(Please send me an email the day before if you wish to meet)}
  % \frsplitdiff{0.53}{0.51}{
  %   \begin{itemize}
  %     \item \emph{Nelma Moreira:} nam@fc.i[/[t]]
  %   \end{itemize}
  %   }{
  %   \begin{itemize}
  %     \item \emph{\textbf{José Proença:}} jose.proenca@fc.up.pt
  %   \end{itemize}
  %   }
  \end{frame}

\begin{frame}{Grading}
  Grading will consist of:
  \begin{itemize}
  \item \textbf{35\%} (\alert{T1}) -- individual \alert{test} for part 1 $(\geq 6)$
  \item \textbf{35\%} (\alert{T2}) -- individual \alert{test} for part 2 $(\geq 6)$
  \item \textbf{70\%} (\structure{FE}) -- individual \structure{final exam} for parts 1 and 2
  \item \textbf{30\%} (\textbf{CW}) -- \textbf{course work} for parts 1 and 2
    \begin{itemize}
      \item groups of at most 2 students
      \item \textbf{10\%} for part 1
      \item \textbf{20\%} for part 2
    \end{itemize}
  \end{itemize}

  % There will be 2 exam periods:
  \frsplitt{
    \begin{exampleblock}{Normal period}\centering
            % ~\mycbox[0.9]{$\structure{T1}\times0.3 + \structure{T2}\times0.4 + \structure{CW}\times0.3
            % (\geq 9.5)$}
            $\alert{T1}\times0.35 + \alert{T2}\times0.35 + \textbf{CW}\times0.3~~~
            (\geq 9.5)$
      ~\\[-4mm]
      Mandatory 75\% attendance in PL
    \end{exampleblock}
  }{
    \begin{alertblock}{Extra period (\emph{recurso})}\centering
      % ~\mycbox[0.9]{$\structure{FE}\times 0.7 + \structure{CW}\times0.3
      % (\geq 9.5)$}      
      $\structure{FE}\times 0.7 + \textbf{CW}\times0.3~~~(\geq 9.5)$
    \end{alertblock}
  }
\end{frame}



\section{Concurrent processes}


\begin{frame}
\frametitle{Programas Sequenciais}
\begin{itemize}
  \item realizam uma função dos dados nos resultados (tese de Church/Turing)

\item A sua semântica pode ser analisada considerando o estado (memória) em cada instante:
$$\sv{S}{P}: State \fun State$$
onde p.e. $State=[Var \fun \mathbb{Z}]$.

$P:$
\begin{algorithmic}
\State $x\gets 1$
\State $y\gets 0$
\While{$x<10$}
\State $y \gets y+x$
\State $x \gets x+1$
\EndWhile
\State \textbf{print} $y$
\end{algorithmic} 
\item Terminam (se não terminarem a sua semântica é indefinida)
\end{itemize} 
\end{frame}

\begin{frame}[fragile]
\frametitle{Equivalência de programas sequenciais}

\only<1->{\emph{Dois programas são equivalentes se realizam a mesma função.}
}
\only<2->{  
\begin{columns}
  \begin{column}[t]{0.3\textwidth}
$P:$
\begin{algorithmic}
\State $x\gets 1$
\end{algorithmic}
\end{column} 
\begin{column}[t]{0.5\textwidth}
$Q:$
\begin{algorithmic}
\State $x\gets 0$
\State $x\gets x+1$
\end{algorithmic} 
\end{column}
\end{columns}}

\only<3->{
$P$ e $Q$ são equivalentes assim como  são equivalentes a 
\begin{itemize}
  \item $P;Q$
\item  $Q;P$ 
\item $R;P$ e $R;Q$ (para qualquer programa $R$)
\item $\ldots$
\end{itemize}}
\only<4->{
A semântica de programas sequênciais é composicional. Por examplo a semântica de $P;Q$ é obtida da semântica de $P$ e de $Q$.}
\end{frame}

\begin{frame}
  \frametitle{Programas Sequênciais vs Concorrentes}
\begin{columns}
  \begin{column}[t]{0.3\textwidth}
$P:$
\begin{algorithmic}
\State $x\gets 1$
\end{algorithmic}
\end{column} 
\begin{column}[t]{0.5\textwidth}
$Q:$
\begin{algorithmic}
\State $x\gets 0$
\State $x\gets x+1$
\end{algorithmic} 
\end{column}
\end{columns}

\begin{itemize}[<+->]
  \item Mas se os executarmos em paralelo, $P || Q$?
\item Qual o significado? $P$ e $Q$ podem intercalar
\begin{enumerate}
  \item não é único: 
\begin{itemize}
\item pode ser  $1$: se for $P$ e depois $Q$
\item  ou $2$: se for $Q$ (primeira instrução) , depois $P$ e depois $Q$ (segunda instrução)
\end{itemize}
\item a semântica não é determinística
\item a equivalência não é preservada por $||$.
\item não é composicional (a semântica de um composta com a semântica do outro)
\end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}
  

\frametitle{Programas Concorrentes/Sistemas Reactivos}
\begin{itemize}%[<+->]
  \item Normalmente não calculam uma função
 \begin{itemize}
\item  Sistemas de operação 
\item Protocolos de comunicação
\item Sistemas Web
\item Sistemas embebidos
\item Processadores multicore
\item Sistemas de controlo de tráfego
\item Portagens
\item $\cdots$
\end{itemize}
\item Então o que fazem?
\item Interagem com o ambiente e entre eles, trocando informação.
\item Normalmente não terminam.
\item Componentes básicas: Processos ou Agentes
\end{itemize}
\end{frame}

\begin{frame}
  

\frametitle{Concorrência vs Paralelismo}
\alert{Concorrência}
\begin{columns}
\begin{column}{0.5\textwidth}
  \begin{itemize}
\item Trabalho lógico simultaneo 
\item Não obriga a multiprocessador
\end{itemize}
\end{column}
  \begin{column}{0.5\textwidth}
   \includegraphics[width=6cm]{src/img/nam/concurnotpar}
\end{column}
\end{columns}
\pause
\alert{Paralelismo}
  \begin{columns}
\begin{column}{0.5\textwidth}
  \begin{itemize}
\item Trabalho físico simultaneo 
\item Obriga a multiprocessador ou várias unidades de processamento.
\end{itemize}
\end{column}
  \begin{column}{0.5\textwidth}
   \includegraphics[width=6cm]{src/img/nam/concurpar}
\end{column}

\end{columns}

\end{frame}

\begin{frame}
  

\frametitle{Processos}

\begin{itemize}[<+->]
  \item Um \alert{processo} é  um programa (sequencial) em execução
\item É descrito por uma máquina de estados (estado= memória, contador de programa, etc)
\item Um \alert{programa multiprocesso} comporta-se como um conjunto de máquinas de estados que cooperam através  da comunicação com o meio.
\item se cada processo tiver um processador, os processos podem executar em paralelo
\item Senão, tem de haver um \alert{escalonador}  para atribuir processos a processadores
 \item Supomos sistemas asíncronos onde \alert{o tempo de execução não interessa}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Sincronização de Processos} 
\begin{itemize}[<+->]
  \item Quando o progresso de um ou mais  processos depende do comportamento de outros processos
\item As interações podem ser de dois tipos:
\begin{enumerate}
\item competição 
\begin{itemize}
\item Ex: competição por um recurso partilhado
\end{itemize}
 \item cooperação

\begin{itemize}
\item O progresso de um processo depende do progresso de outros
\item Ex: \emph{rendezvous}: conjunto de pontos de controlo em que cada processo só pode avançar quando todos os processos estiverem no ponto de controlo respectivo.
\item Ex: \emph{produtor/consumidor}
\end{itemize}
 
\end{enumerate}
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Competição: Ler e escrever num disco $D$} 
%
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{algorithmic}
\Procedure{disk-read}{$x$}
\State{$D.seek(x);$}
\State{$r\gets D.read();$}
\State{\textbf{return} $r$;}
\EndProcedure
\end{algorithmic}
\end{column}
\begin{column}{0.5\textwidth}
\begin{algorithmic}
\Procedure{disk-write}{$x$,$v$}
\State{$D.seek(x);$}
\State{$D.write(v);$}
\State{\textbf{return};}
\EndProcedure
\end{algorithmic}
\end{column}
\end{columns}
\bigskip
\pause

\begin{center}
\begin{algorithmic}
\Call{disk-read}{$x$} $||\;$ \Call{disk-write}{$y$,$v$} 
\end{algorithmic}
\only<2->{
\includegraphics[width=7cm]{src/img/nam/readwrite}}

\pause Pode acontecer que se leia em $x$ o valor de $y$.

\pause \alert{Solução}: Não permitir que estas operações executem em simultaneo $\Imp$ \alert{Exclusão Mútua}  
\end{center}
\end{frame}


\begin{frame}
\frametitle{Cooperação:produtor/consumidor} 

\begin{itemize}[<+->]
  \item O produtor \alert{produz} produtos
\item O consumidor \alert{consume} os produtos, e
\item Um produto não pode ser consumido \alert{antes} de ser produzido
\item Todos os produtos que são produzidos são consumidos  \alert{exactamente} uma  vez
\item Implementação: um \emph{buffer} partilhado de tamanho $k\geq 1$
\item Pode ser uma fila: o produtor acrescenta um novo produto no \alert{fim} da fila e o consumidor consome o produto do \alert{início} da fila
\item O produtor tem de esperar quando o buffer \alert{está cheio}
\item O consumidor só tem de esperar quando o buffer \alert{está vazio}
\item \alert{Invariante de sincronização}: se $\#p$ número de produtos produzidos e $\#c$ número de produtos consumidos:
$$ (\#c\geq 0)\land    (\#p\geq \#c)\land  (\#p\leq \#c+k)$$
\end{itemize}
  
\end{frame}


\begin{frame}
\frametitle{Exclusão Mútua} 
\begin{itemize}[<+->]
  \item \alert{Secção Crítica}: porção de código que só pode ser executado por um processo num dado instante
\item Supõe-se que a execução da secção crítica por um só processo termina.
\item \alert{MUTEX}  o problema consiste em ter
\begin{enumerate}
  \item  um algoritmo de entrada $acquire\_mutex()$
\item um algoritmo de saída $release\_mutex()$
\end{enumerate}
\item Enquadrando a seção crítica garantem
\begin{description}
  \item[Exclusão mútua]: que o código da zona crítica é executado no máximo por um processo em cada instante.
\item[\emph{Starvation-freedom}]: cada processo que invoca $acquire\_mutex()$ termina, permitindo assim que os processos que querem entrar na zona crítica o possam fazer.
\end{description}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exclusão Mútua} 
 \begin{algorithmic}
 \Procedure{$protected\_code$}{$in$}
\State \Call{$acquire\_mutex$}{\ };
\State $r\gets cs\_code(in)$;
\State \Call{$release\_mutex$}{\ };
\State{\textbf{return} $r$;}
\EndProcedure
 \end{algorithmic}
\end{frame}


\begin{frame}
\frametitle{Propriedades de \emph{Safety} e \emph{Liveness}}  
\begin{description}[<+->]

  \item[\emph{Safety} (segurança)] Nada de mal acontece. Podem ser invariantes. Têm de ser sempre verdade. Ex: Exclusão mútua
  \item[\emph{Liveness} (vivacidade)] Algo de bom irá acontecer. Terão de acontecer ao longo da execução do sistema. 
\begin{itemize}
  \item \alert{Starvation-freedom} 
\item \alert{Deadlock-freedom}: em cada instante $\tau$ se vários processos invocaram $acquire\_mutex$ e essa invocação não terminou, então para $\tau'>\tau$ algum terá que terminar essa invocação.

\item \alert{Bypass limitado}: Suponhamos $n$ processos em competição e suponhamos que um  ganha. Existe $f(n)$ tal que cada processo que invoca $acquire\_mutex$ perde no máximo $f(n)$ vezes para os outros.
\end{itemize}
\centerline  \emph{Bypass} limitado $\Imp$ \emph{Starvation-freedom}(=\emph{Bypass} finito) $\Imp$ \emph{Deadlock-freedom}
\end{description}
\end{frame}

\section{Modelação de Sistemas Concorrentes}
\only<presentation>{\begin{frame}
  \frametitle{Modelação de Sistemas Concorrentes}
  Pretendemos modelar os sistemas concorrentes/reactivos de modo a
  \begin{itemize}
    \item  poder assegurar as propriedades indicadas
    \item garantir a sua correção
    \item determinar se uma implementação está de acordo com a especificação
    \item em geral é díficil compreender o comportamento de um sistemas concorrentes
  \end{itemize}
\end{frame}}
\begin{frame}{Máquina de Vendas}
\begin{columns}\begin{column}{0.5\textwidth}
  \includegraphics[width=5cm]{src/img/nam/vendingmachine} 
\end{column}

\begin{column}{0.5\textwidth}
\textbf{Acções de comunicação} (\alert{observáveis})
  \begin{itemize}
    \item Pressionar um botão
\item Inserir moedas
\item Injectar uma bebida/comida
  \end{itemize}
\pause \textbf{Acções internas}

(\alert{ não observáveis})
\begin{itemize}
    \item Escolher a bebida
\item Mecanismo para injectar o produto certo
\item Tirar o dinheiro do bolso
\item Verificar as moedas inseridas
\item Pegar na bebida
  \end{itemize}

\end{column}
  \end{columns}

\end{frame}

\begin{frame}{Modelo abstracto de um processo}

\begin{itemize}[<+->]
  \item Um processo é descrito usando um conjunto de ações, \alert{alfabeto do processo}
\item $Com$: conjunto de ações de comunicação (actividades observáveis) $a,b,c,\ldots$
\item $Int$: conjunto de acções internas (computações locais)   $[a],[b],[c],\ldots$
\item  $Act=Com\cup Int$ conjunto de todas as ações
\item A execução de uma \alert{ação} muda o estado do processo:
 \only<6>{
\begin{center}
\begin{tikzpicture}[>=stealth, shorten >=1pt, auto, node distance=3cm,initial text={}]
\node[state,  inner sep=1pt, minimum size=5pt] (S0){};
\node[state,  inner sep=1pt, minimum size=5pt][right of =S0] (S1){};
\path[->](S0) edge [bend left] node {inserir moeda}(S1)
         (S1) edge  [bend left] node { sair café}(S0);
\end{tikzpicture}
\end{center}
}

\only<7>{
\begin{center}
\begin{tikzpicture}[>=stealth, shorten >=1pt, auto, node distance=3cm,initial text={}]
\node[state,  inner sep=1pt, minimum size=5pt] (S0){};
\node[state,  inner sep=1pt, minimum size=5pt][right of =S0] (S1){};
\path[->](S0) edge [bend left] node {\color{blue} a}(S1)
         (S1) edge  [bend left] node { \color{blue}b}(S0);
\end{tikzpicture}

Usar só letras para simplificar
\end{center}
}
\end{itemize}
  
\end{frame}

\end{document}
